\documentclass[xcolor={usenames,dvipsnames}]{beamer}

\usepackage[T1]{fontenc}
\usepackage{verbatim}
\usepackage{listings}

\title{Introduction to Dependent Types}
\subtitle{Eagan Technology Unconference}
\author{Joseph Ching}
\date{September 22, 2015}

\usetheme{Antibes}
\usecolortheme{beaver}

\newcommand{\hkeyword}[1]{\textcolor{TealBlue}{\textsc{#1}}}
\newcommand{\hfunction}[1]{\textcolor{Green}{\textsc{#1}}}
\newcommand{\htycon}[1]{\textcolor{Blue}{\textsc{#1}}}
\newcommand{\hvalcon}[1]{\textcolor{Red}{\textsc{#1}}}
\newcommand{\hkind}[1]{\textcolor{Fuchsia}{\textsc{#1}}}
\newcommand{\hclass}[1]{\textcolor{Magenta}{\textsc{#1}}}
\newcommand{\htyfam}[1]{\textcolor{OliveGreen}{\textsc{#1}}}
\newcommand{\hcomment}[1]{\textcolor{Grey}{\textsc{#1}}}
\newcommand{\hother}[1]{\textcolor{Black}{\textsc{#1}}}

\lstdefinestyle{hask}{
  basicstyle=\ttfamily\scriptsize\color{Black},
  sensitive=true,
  morecomment=[l][\color{Gray}\ttfamily\tiny]{--},
  morecomment=[s][\color{Gray}\ttfamily\tiny]{\{-}{-\}},
  morestring=[b]",
  stringstyle=\color{Maroon},
  showstringspaces=false,
  numberstyle=\color{Red},
  numberblanklines=true,
  showspaces=false,
  breaklines=true,
  showtabs=false,
  moredelim=**[is][\color{TealBlue}]{@kw}{@},
  moredelim=**[is][\color{Green}]{@f}{@},
  moredelim=**[is][\color{Blue}]{@tc}{@},
  moredelim=**[is][\color{Red}]{@vc}{@},
  moredelim=**[is][\color{Fuchsia}]{@dk}{@},
  moredelim=**[is][\color{Magenta}]{@cc}{@},
  moredelim=**[is][\color{OliveGreen}]{@tf}{@},
  moredelim=**[is][\color{Maroon}]{@str}{@},
  escapeinside={{@|}{@}},
  % Keywords
  emph=
  {[1]
    module,import,qualified,hiding,as,foreign,infix,infixr,infixl,
    where,let,in,case,of,if,then,else,do,rec,proc,forall,pi,
    type,newtype,data,family,class,instance,deriving,default
  },
  emphstyle={[1]\color{TealBlue}\textbf},
  % functions
  emph=
  {[2]
    map,filter,foldr,length,fmap,id
  },
  emphstyle={[2]\color{Green}},
  % type constructors
  emph=
  {[3]
    Char,String,Bool,Int,Integer,Double,Float,Ordering,Maybe,Either,IO
  },
  emphstyle={[3]\color{Blue}\textbf},
  emph=
  % value constructors
  {[4]
    True,False,Nothing,Just,Left,Right,GT,LT,EQ
  },
  emphstyle={[4]\color{Red}\textbf},
  % type classes, contexts, constraints
  emph=
  {[5]
    Show,Read,Eq,Ord,Enum,Bounded,Num,
    Monoid,Functor,Foldable,Traversable,Applicative,Alternative,Monad,Comonad,Arrow
  },
  emphstyle={[5]\color{Magenta}\textbf},
  % kinds
  emph=
  {[6]
    Constraint,AnyK,OpenKind,BOX
  },
  emphstyle={[6]\color{Fuchsia}\textbf},
  % type families
  emph=
  {[7]
    Plus,Mult
  },
  emphstyle={[7]\color{OliveGreen}\textbf},
  % foreign languages
  emph=
  {[8]
    enum, interface
  },
  emphstyle={[8]\color{TealBlue}\textbf},
}

\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Title Page
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[plain]
  \titlepage
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Table of Content
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Table of Contents}
  \tableofcontents[pausesections]
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Preface
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Preface}

\begin{frame}{Quick Question}
  How many are familiar with this topic?
\end{frame}

\begin{frame}{A Joke}
  This is not a \texttt{m-} tutorial.

  \pause

  Nor is it a \texttt{lens} tutorial
  \pause
  (aka the new new \texttt{m-} tutorial\ldots

  \pause
  \ldots because \texttt{arrows} \textit{were} the new \texttt{m-} tutorials).

\end{frame}


\begin{frame}{About This Talk}
    \texttt{Agda}, \texttt{Idris}, \texttt{Coq} and co$^*$ have full support for dependent types.\\
    \pause
    Because of that, it's harder to see the build up, so we won't be directly using them in this talk.\\
    \pause
    \textit{\tiny{Honestly though, it's because they're way over my head :(}}\\
    \textit{\tiny{(*) There was another mini joke here\ldots}}
\end{frame}

\begin{frame}{About This Talk}
  But we will be using \texttt{Haskell} though :)\\
  \pause
  It's not truely dependent, but we can do more and more with each \texttt{language extension} that comes along.\\
  For the examples, there also will be loose translation to imperative/OOP; though please keep in mind that they are not the same thing at all.
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Review of Basics}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Test}
% Test highlighting examples
\begin{frame}[fragile]{Test}
  Syntax highlighting test reference, to be removed later.

  \begin{lstlisting}[style=hask]
      -- Comment
      data Maybe a = Nothing | Just a
                     deriving (Show, Eq)
 
      fmap :: Functor f => (a -> b) -> f a -> f b
      map _ @vc[]@     = @vc[]@
      map f (x@vc:@xs) = f x @vc:@ map f xs
 
      type family @tfTF@ a :: @dk*@
      type instance @tfTF@ Int = Bool
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Test}
  Couldn't quite yet get listing to work with overlay yet.

  \begin{lstlisting}[style=hask]
      {- block comment -}
      @ffoo@ :: Bool -> Int -> String
      @ffoo@ False @vc0@ = "Bad"
      @ffoo@ True  @vc0@ = "Questionable"
      @ffoo@ False n = "Fake"
      @ffoo@ True  n = "Read"
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Test}
  Pausing within listing is ok?

  \begin{lstlisting}[style=hask]
    {-# LANGUAGE KitchenSink #-}
    @fzipWith@ :: (a -> b -> c) -> @vc[@a@vc]@ -> @vc[@b@vc]@ -> @vc[@c@vc]@ @|\pause@
    @fzipWith@ _ @vc[]@     _      = @vc[]@ @|\pause@
    @fzipWith@ _ _      @vc[]@     = @vc[]@ @|\pause@
    @fzipWith@ f (x@vc:@xs) (y@vc:@ys) = f x y @vc:@ @fzipWith@ f xs ys
  \end{lstlisting}

  better yet

  \begin{lstlisting}[style=hask]
    {-# LANGUAGE KitchenSink #-}
    @fzipWith@ :: (a -> b -> c) -> @vc[@a@vc]@ -> @vc[@b@vc]@ -> @vc[@c@vc]@
    @fzipWith@ f (x@vc:@xs) (y@vc:@ys) = f x y @vc:@ @fzipWith@ f xs ys
    @fzipWith@ _ _      _      = @vc[]@
  \end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Values and Types}

\begin{frame}[fragile]{Values and Types}
  Values has Types, or \hvalcon{Values} are classified by \htycon{Types}.\\

  \begin{lstlisting}[style=hask]
    @|\ldots@, @vc-1@, @vc0@, @vc1@, @vc2@, @vc3@, @|\dots@ :: Int @|\pause@
    True, False :: Bool @|\pause@
    @str'a'@, @str'b'@, @str'c'@ :: Char @|\pause@
    "abc" :: String @|$\sim$@ @tc[@Char@tc]@

  \end{lstlisting}

  \tiny{\hvalcon{Values} are also called \hvalcon{Terms}}
\end{frame}

\begin{frame}[fragile]{About Types}
  How are the types defined?\\
  \begin{itemize}
    \item Some are built in magic: \htycon{Int}, \htycon{Char}, functions
    \pause
    \item Some are built in sugar: list, tuples
      \begin{itemize}
        \item We can still define these ourselves without the sugar
      \end{itemize}
    \pause
    \item Rest can be user defined: \htycon{Bool}, \htycon{String}, \htycon{Maybe}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Empty and Unit Types}
  Define new data type with \hkeyword{data}.
  \pause
  \begin{itemize}
    \item Left hand side (\htycon{LHS}) - \htycon{Type} constructor
    \pause
    \item Right hand side (\hvalcon{RHS}) - \hvalcon{Value} constructor
    \pause
  \end{itemize}

  \ \\
  \begin{lstlisting}[style=hask]
    data Bool = False | True
  \end{lstlisting}

  Here, \htycon{Bool} is the \htycon{Type} constructor, \hvalcon{True} and \hvalcon{False} are \hvalcon{Value} constructors.\\
  \textit{\tiny{Does this remind you of anything?}}
\end{frame}

\begin{frame}[fragile]{Empty and Unit Types}
  Define new data type with \hkeyword{data}.
  \begin{itemize}
    \item Left hand side (\htycon{LHS}) - \htycon{Type} constructor
    \item Right hand side (\hvalcon{RHS}) - \hvalcon{Value} constructor
  \end{itemize}

  \ \\
  \begin{lstlisting}[style=hask]
    data Bool = False | True
  \end{lstlisting}

  A loose translation:
  \begin{lstlisting}[style=hask]
    enum Bool { False, True }
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Sum Types}
  Simply, \htycon{Types} with more than one constructors.
  \pause
  \begin{lstlisting}[style=hask]
    data Bool = False | True
    data @tcWeekdays@ = @vcSunday@ | @vcMonday@ | @vcTuesday@ | @vcWednesday@
                  | @vcThursday@ | @vcFriday@ | @vcSaturday@
  \end{lstlisting}

  \pause
  \ \\
  Can parametrize over another type:
  \pause
  \begin{lstlisting}[style=hask]
    data @tcIdentity@ a = @vcIdentity@ a
  \end{lstlisting}

  \pause
  \ \\
  A \textit{very} loose translation \tiny{(assuming capitalization implies constructor)}:
  \begin{lstlisting}[style=hask]
    enum @tcIdentity@<T> {
      @vcIdentity@(T t)
    }
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Sum Types}
  Simply, \htycon{Types} with more than one constructors.
  \begin{lstlisting}[style=hask]
    data Bool = False | True
    data @tcWeekdays@ = @vcSunday@ | @vcMonday@ | @vcTuesday@ | @vcWednesday@
                  | @vcThursday@ | @vcFriday@ | @vcSaturday@
  \end{lstlisting}

  \ \\
  Can parametrize over another type:
  \begin{lstlisting}[style=hask]
    data @tcIdentity@ a = @vcIdentity@ a
  \end{lstlisting}

  \ \\
  And its \htycon{Type}:
  \begin{lstlisting}[style=hask]
    @vcIdentity@ :: a -> @tcIdentity t
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Sum Types}
  Another example:
  \begin{lstlisting}[style=hask]
    data Maybe a = Nothing | Just a
  \end{lstlisting}

  \pause
  \ \\
  The \textit{very} loose translation:
  \begin{lstlisting}[style=hask]
    enum Maybe<T> {
      Nothing,
      Just(T t)
    }
  \end{lstlisting}

  \pause
  \ \\
  The \htycon{Types} of the two \hvalcon{Value} constructors:
  \begin{lstlisting}[style=hask]
    Nothing :: Maybe a
    Just    :: a -> Maybe a
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Sum Types}
  A more involved example with \htycon{Either}:
  \begin{lstlisting}[style=hask]
    data Either a b = Left a | Right b
  \end{lstlisting}

  \pause
  \ \\
  Another \textit{very} loose translation:
  \begin{lstlisting}[style=hask]
    enum Either<T1, T2> {
      Left(T1 t1),
      Right(T2 t2)
    }
  \end{lstlisting}

  \pause
  \ \\
  The two \hvalcon{Value} constructors have \htycon{Types}:
  \begin{lstlisting}[style=hask]
    Left  :: a -> Either a b
    Right :: b -> Either a b
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Product Types}
\end{frame}

\begin{frame}[fragile]{Types with Recursion}
\end{frame}

\begin{frame}[fragile]{Phantom Types}
\end{frame}

\begin{frame}[fragile]{Language Extension - GADTs}
\end{frame}

\begin{frame}[fragile]{Type Synonyms}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Functions}

\begin{frame}[fragile]{Functions}
\end{frame}

\begin{frame}[fragile]{Higher-order Functions}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Q & A
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Questions}

% q&a
\begin{frame}
  Questions?
\end{frame}


\end{document}

